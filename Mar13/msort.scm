
;; A merge sort that actually is stable.  Unlike the last one I wrote,
;; where I did split a list by tearing it apart element by element,
;; this algorithm simply cuts it in about the middle.

(define (msort l <)

  (define (split l len)
    (define len/2 (arithmetic-shift len -1))
    (values (take l len/2)
	    len/2
	    (drop l len/2)
	    (- len len/2)))

  (define (sort l len)
    (cond ((null? l) l)
	  ((null? (cdr l)) l)
	  (else
	   (letv ((l1 len1 l2 len2) (split l len))
		 (merge (sort l1 len1)
			(sort l2 len2))))))

  (define (merge l1 l2)
    (cond ((null? l1) l2)
	  ((null? l2) l1)
	  (else
	   (let-pair ((a1 r1) l1)
		     (let-pair ((a2 r2) l2)
			       (if (< a2 a1)
				   (cons a2
					 (merge l1 r2))
				   (cons a1
					 (merge r1 l2))))))))

  (sort l (length l)))

(TEST
 > (msort '() <)
 ()
 > (msort '(1) <)
 (1)
 > (msort '(1 2) <)
 (1 2)
 > (msort '(2 1) <)
 (1 2)
 > (msort '(2 1 4 1 3 8 -3) <)
 (-3 1 1 2 3 4 8)
 > (msort '(2 1 4 1 3 8 -3) <)
 (-3 1 1 2 3 4 8)
 > (define  l (map list '(2 1 4 1 3 8 -3) (iota 7)))
 > l
 ((2 0) (1 1) (4 2) (1 3) (3 4) (8 5) (-3 6))
 > (msort l (on car <))
 ((-3 6) (1 1) (1 3) (2 0) (3 4) (4 2) (8 5))
 > (msort (reverse l) (on car <))
 ((-3 6) (1 3) (1 1) (2 0) (3 4) (4 2) (8 5))
 )

;; But are those tests conclusive? Instead of trying to be smart and
;; find all the edge cases, do random testing, hoping to cover all of
;; them:

;; (define (random-natural0.pos-list top len)
;;   (map (lambda (i)
;; 	 (cons (random-integer top)
;; 	       i))
;;        (iota len)))

;; but we need duplicates to test for stable sorting.

;; (define (has-duplicates? l = ref)
;;   ;; simple but inefficient in an eager language (and delete-duplicates
;;   ;;    is O(n^2) anyway):
;;   ;; (equal? (delete-duplicates l (on ref =)) l)
;; ...)

;; better generate the list with guaranteed duplicates in the first
;; place.

(define (random-natural0.pos-list/duplicates top len)
  (define (rnd)
    (random-integer top))

  (assert (>= len 2)) ;; for the duplicates to work

  ;; guarantee at least one duplicate, by choosing a value and its two
  ;; positions in advance
  (let ((dup-poss (let* ((rndpos (lambda () (random-integer len)))
			 (pos0 (rndpos)))
		    (let retry ()
		      (let ((pos1 (rndpos)))
			(if (= pos0 pos1)
			    (retry)
			    (list (min pos0 pos1) (max pos0 pos1)))))))
	(dup-val (rnd)))
    (let lp ((out '())
	     (dup-poss (reverse dup-poss))
	     (i (dec len)))
      (if (negative? i)
	  out
	  (letv ((val poss*)
		 (if (null? dup-poss)
		     (values (rnd) dup-poss)
		     (let-pair ((pos poss*) dup-poss)
			       (if (= pos i)
				   (values dup-val poss*)
				   (values (rnd) dup-poss)))))
		(lp (cons (cons val i) out)
		    poss*
		    (dec i)))))))

;; > (random-natural0.pos-list/duplicates 3 6)
;; ((1 . 0) (0 . 1) (2 . 2) (1 . 3) (0 . 4) (0 . 5))
;; > (random-natural0.pos-list/duplicates 1000 3)
;; ((139 . 0) (143 . 1) (143 . 2))
;; > (random-natural0.pos-list/duplicates 1000 3)
;; ((497 . 0) (497 . 1) (887 . 2))
;; > (random-natural0.pos-list/duplicates 1000 2)
;; ((49 . 0) (49 . 1))

(define (every-equal? = l)
  (every ((lambda (x0)
	    (lambda (x) (= x x0))) (car l))
	 (cdr l)))

(define (t1 l)
  ;; l: as generated by random-natural0.pos-list/duplicates
  (warn "len,max" (length l) (apply max (map car l)))
  (let ((rising (msort l (on car <)))
	(falling (msort l (on car >))))
    (assert-and
     ;; assert-and is like |and| but gives an exception when a
     ;; subexpression is false, thus allowing to debug the issue
     ;; interactively
     (equal? (msort rising (on cdr <))
	     l)
     (if (equal? rising falling)
	 ;; that happens (actually must happen) in case all |car|s are
	 ;; the same value.
	 (every-equal? (on car =) l)
	 ;; else: usual case
	 #t)
     (not (equal? rising
		  (msort (reverse l) (on car <))))
     ;; ^ since duplicates are guaranteed
     (equal? rising
	     (msort falling (on car <)))
     (equal? (reverse rising)
	     (msort (reverse rising) (on car >)))
     (equal? (reverse falling)
	     (chain rising
		    (reverse)
		    (msort (on car <))))
     ;; there are multiple superfluous tests. (Which ones exactly?..)
     (equal? rising
	     (chain rising
		    (reverse)
		    (msort (on car <))
		    (reverse)
		    (msort (on car <)))))))

;; |chain| is the same as
;; http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/->

(TEST
 > (every true?
	  (map (lambda (i)
		 (define len (+ 2 (* i (random-integer 20))))
		 (define top (+ 2 (* (+ i (random-integer 20))
				     (random-integer 10))))
		 (t1 (random-natural0.pos-list/duplicates top len)))
	       (iota 20 1)))
 #t)
